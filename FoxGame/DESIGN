
<GL> foxgame.py: game logic component

<UI> bubbles.py (or any other): user interface / simulator component

<Ctl> tradlib.py (and others): controller component, may be AI or filter


<Launcher> main: command line parser and game launcher


* General flow *

1- User invokes <Launcher>, specifying components preferences (safe defaults)
   <Launcher>:
     - parses command line / config file
     - dynamically loads needed components [5]
     - builds factory callables for <Ctl> controllers [6]
     - builds factory callables for <GL> Game
     - passes factories to <UI>
     - gives control to <UI> [2]


2- <UI> obtains application control
   Basic option, no need to access factory properties:
   <UI>:
    - supplies fox/hare mover for user controlled pawn
    - runs game main loop, eventually customized (menus and so on)
    - builds game from factory [3]
    - passes controller factories to game
    - main loop for a game:
      - keep clock
      - locally update user input (opt)
      - call game.tick(time_delta) [4]
      - reads updated game state (redraw goes here)
      - sleep
   Option 2, <UI> manages game setup:
     - we need configurable factory/setup objects


3- <GL>: game init
   Game object:
    - obtains pawn controller factories (<Ctl> or <UI>)
    - initializes game
    - creates instances of controllers
    - game rules determine what goes on here!


4- <GL>: game tick
   Game object:
    - gets time delta
    - updates input from controllers
      Note: controllers, especially AI ones, need to read game state
    - update game state


* Time to go deep with details *

5- Component loading
   Python makes this easy: a module (or a package) for each component
   implementation. Simple interface: refer to component modules only by name,
   then check some versioning module variable.
   <Launcher>:
    - launcher called with --ui=bubbles
    - dynamically import 'bubbles'
    - check module.foxgame_UI_version
    - interfaces described in this doc are version (major=1, minor=0)
   Other variable: foxgame_Ctl_version, foxgame_GL_version
   Compatibility constraints on version:
    - all major numbers must be the same (major = breaking change)
    - GL_version.minor >= Ctl_version.minor
    - GL_version.minor >= UI_version.minor
    - filter chain: calling Ctl_version.minor > answering Ctl_version.minor


6- Controllers configuration
   Need to give configuration properties to controllers and set up a filter
   chain.
   Note that a controller may want to keep state between games. It can do so
   by using module state (quick and dirty) or by providing callable factory
   classes (often overkill but allows for better control).
   Two type of filters: preprocess and postprocess.
   Preprocess filters (prefilters):
    - may be stateful (but usually aren't)
    - are called at every controller update
    - are executed one after another, i.e.:
      for filter in prefilters:
          filter.process()
    - may be required by another prefilter/controller
      (topological sort to decide call order, or property call to fill the
       required values when needed)
    - don't modify original data: just output data in new form
      e.g.: a filter may compute direction/distance of the prey wrt the fox
            and output it in a new variable. Then a second filter may read
            direction value and discretize it (N, NE, E, ...)
    
    Postprocess filters (postfilters):
     - may be stateful (and usually are)
     - are called at every controller update
     - transform the result each one after another, i.e:
       result = controller()
       for filter in postfilters:
           result = filter.process(result)
     - call order as specified at configuration time
     